CSS: style.css

PerfExpert Reference
====================

This document explains features of PerfExpert in detail. For an easy introduction to PerfExpert and what it looks like, please see the [Quick Start Guide](http://www.tacc.utexas.edu/perfexpert/quick-start-guide/). For information on the PerfExpert output, see [PerfExpert metrics](http://www.tacc.utexas.edu/perfexpert/metrics).

Profiling using PerfExpert has two stages: 

1. Running your program with a special application, `perfexpert_run_exp`, to collect performance-related information about your program
2. Running `perfexpert` on the file generated by `perfexpert_run_exp`

perfexpert\_run\_exp
--------------------

`perfexpert_run_exp` is a shell script that runs your program multiple times (typically 5-6 times), during which, it will measure different performance-related metrics. The syntax for its invocation is:

    $ perfexpert_run_exp 

    Usage: perfexpert_run_exp [OPTION...] program-name [arguments]
    Program to gather measurements for use with PerfExpert
    
      -s, --structure FILE		Use FILE as program structure (generated by hpcstruct)
      -o, --output FILE.xml		Save measurements to FILE.xml
      -n, --no-debug		Do not switch to debug mode if program fails to execute with PerfExpert

Hence, if your application is called `hello-world` which takes in a name as an input parameter, you would run it with PerfExpert as:

    $ perfexpert_run_exp ./hello-world John

**Note to users of [TACC](http://www.tacc.utexas.edu/) machines**: The `perfexpert_run_exp` command internally uses `ibrun`. Hence, even if `hello-world` was an MPI application, you would still invoke it in the same manner as shown above.

At the end of the execution, the above command would generate a file: `experiment-${JOB_NAME}.o${JOB_ID}.xml` (or just `experiment.xml` if the command was ran outside of a batch submission system). This file contains the recorded performance information for your application.

### Working with shell scripts / complicated program invocations
If your program invocation involves using shell redirects ('`<`' or '`>`' for setting the standard input or standard output), you need to place the command into a shell script. Also, in such cases, the `--structure` option needs to be used with `perfexpert_run_exp`. This is required so that PerfExpert (and in turn, the underlying software - HPCToolkit) can learn about the functions and loops in the application being profiled. The value passed with `--structure` is the name of the file generated after running `${PERFEXPERT_HPCTOOLKIT_HOME}/bin/hpcstruct` on your application (`<application>.hpcstruct`). For instance, if your application (binary) is called `hello-world` and if you decide to place it into a shell script `run-hello-world.sh`, which reads:

    $ cat run-hello-world.sh

    echo John | ./hello-world

Then you would use the following commands to run your application with PerfExpert:

    $ ${PERFEXPERT_HPCTOOLKIT_HOME}/bin/hpcstruct hello-world    # This generates hello-world.hpcstruct
    
    $ perfexpert_run_exp --structure hello-world.hpcstruct ./run-hello-world.sh

Another note of importance is that the shell script must not use the `#!` line for specifying the interpreter, i.e. the first line in the `run-hello-world.sh` should not invoke the shell. This limits user shell scripts (that are passed to `perfexpert_run_exp`) to those using the Bourne shell syntax. We are working to find a way around this limitation.

### Error reports
If the application or command passed to `perfexpert_run_exp` fails to run successfully, PerfExpert switches to debug mode to collect details about the failure. The following details are collected and saved to the `perfexpert_debug.out` file:

1. Output of `uname -a` (Operating System version details)
2. Contents of `/proc/cpuinfo` (Details of processor)
3. The command that failed to run correctly
4. Stack trace for the failed command
5. Debug information from HPCToolkit

We request that you send this file to us to enable us to correct the behavior of PerfExpert.

The failed execution of any command is detected by means of the return code. If the return code is non-zero, `perfexpert_run_exp` starts collecting the debug information. If your application does not explicitly return an error code, this may cause `perfexpert_run_exp` to mistakenly think that the command failed. To disable switching to debug mode, use the `--no-debug` or `-n` option to `perfexpert_run_exp`, e.g.:

    $ perfexpert_run_exp --no-debug ./command-with-non-zero-exit-code

perfexpert
----------

Once the performance metrics have been collected for your application using `perfexpert_run_exp`, the measurements are analyzed using `perfexpert`.

    $ perfexpert
    
    USAGE: perfexpert [OPTIONS] <threshold> <experiment.xml> [<experiment.xml>]
    
     -h,--help                              Show this screen
     -a,--aggregate                         Show whole-program information only
     -r[=<limit>],--recommend[=<limit>]     Recommend suggestions for optimization
     -t=<thread#>,--threads=<thread#>       Show information for specific threads
    
     <threshold>                            Threshold between 0 and 1
     <experiment.xml>                       experiment.xml file generated using `perfexpert_run_exp'
     [<experiment.xml>]                     Second experiment.xml file, for comparison only. Not valid with -r,--recommend

Generally, the command would be executed as:

    $ perfexpert 0.1 experiment.xml

The `0.1` refers to the threshold, meaning that we are interested in functions and loops that take at least 10% of the total running time. The `experiment.xml` is the result of running `perfexpert_run_exp` on your application. This will display the PerfExpert metrics, which are explained in detail [here](http://www.tacc.utexas.edu/perfexpert/metrics).

It is also possible to compare two runs (say naive and optimized executions of the same code) by passing the corresponding `experiment.xml` files to `perfexpert`:

    $ perfexpert 0.1 experiment-naive.xml experiment-optimized.xml

Often, you might be interested in getting an overview of the program performance instead of getting details of each code segment. To get the aggregate (program-wide) performance information, use the `--aggregate` or `-a` option to `perfexpert`. In this case, the threshold argument is not interpreted but is still required.

### Thread-specific metrics
By default, PerfExpert combines performance metrics from all threads. It might be useful to look at performance information for specific threads (or to combine performance information of certain threads). This can be done using the `--threads` or `-t` option. There are various ways to identify the threads whose information should be displayed:

* Using the thread IDs: `--threads=0` for information specific to thread #0
* Listing multiple thread IDs: `--threads=1,3,5,7`
* Using bounded range: `--threads=1-4` for metrics for threads 1, 2, 3 and 4
* Using unbounded range: `--threads=1-` for all threads other than thread #0

The displayed output for all of the above combinations follows the same semantics, as described in <http://wwww.tacc.utexas.edu/perfexpert/metrics> but the values refer to the specific selected threads.

Getting recommendations for optimization
----------------------------------------

PerfExpert can recommend optimizations to your code based on the analysis output. The recommendations can be obtained by using the `-r` or `--recommend` switch.

This switch takes an optional value that indicates the number suggestions to be displayed. If left unspecified, PerfExpert shows all options that it thinks are applicable.

A sample execution with recommendations is shown below:

    $ perfexpert 0.1 experiment.xml -r | less
    Input file: "/home/klaus/experiment.xml"
    
    ********************************************************************************
    Loop in function kernel1A() at RunKernel.cpp:146 (56.3% of the total runtime)
    ********************************************************************************
    
    use the "-no-unroll-aggressive" compiler flag
    --------------------------------------------------------------------------------
    
    lower the loop unroll factor
    This optimization reduces the code size, which may improve the instruction cache
    performance.
    
    loop i step 4 {
      code_i;
      code_i+1;
      code_i+2;
      code_i+3;
    }
     =====>
    loop i step 2 {
      code_i;
      code_i+1;
    }

* * *
